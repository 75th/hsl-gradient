@use 'sass:list';
@use 'sass:map';
@use 'sass:math';
@use 'sass:meta';
@use 'sass:color';

@function hsl-from-color($color) {
  @return hsla(color.hue($color), color.saturation($color), color.lightness($color), color.alpha($color));
}

@function structure-stop($stop) {

}

@function normalize-structured-stop($stop, $stop-index, $stop-count) {
  // Normalize position.
  $position: map.get($stop, 'position');
  @return $stop;
}

@function hsl-gradient-stops($rgb-stops...) {
  $i: 0;
  $structured-stops: ();
  // What direction to go if two adjacent stops are exactly 180° apart in hue
  // and the current direction is 'closest'. (If the current direction is
  // 'farthest', 180°-apart colors will proceed in the opposite of the default
  // fallback direction.)
  $default-fallback-direction: 'clockwise';

  $stop-count: list.length($rgb-stops);
  $stop-index: 1;
  // Loop over provided arguments.
  @each $rgb-stop in $rgb-stops {
    // If a stop is just a string, it's the new default fallback direction.
    $structured-stop: ();
    @if meta.type-of($rgb-stop) == 'string' {
      $default-fallback-direction: $rgb-stop;
    } @else {
      @each $rgb-stop-token in $rgb-stop {
        // Color.
        @if meta.type-of($rgb-stop-token) == 'color' {
          $structured-stop: map.set($structured-stop, 'color', hsl-from-color($rgb-stop-token));
        }
        // Position or extra turns.
        @else if meta.type-of($rgb-stop-token) == 'number' {
          // Extra turns.
          @if math.is-unitless($rgb-stop-token) {
            $structured-stop: map.set($structured-stop, 'extra-turns', $rgb-stop-token);

            @if $stop-index == 0 {
              @warn 'Extra turns on the first gradient stop are ignored; they apply to the transition from the previous stop, not into the next one.';
            }
          }
          // Position.
          @else {
            $structured-stop: map.set($structured-stop, 'position', $rgb-stop-token);
          }
        }
        // Direction into this stop.
        @else if meta.type-of($rgb-stop-token) == 'string' {
          $structured-stop: map.set($structured-stop, 'direction', $rgb-stop-token);

          @if $stop-index == 0 {
            @warn 'Direction on the first gradient stop is ignored; it applies to the transition from the previous stop, not into the next one.'
          }
        }
      }

      $structured-stops: list.append($structured-stops, normalize-structured-stop($structured-stop, $stop-index, $stop-count));
    }

    $stop-index: $stop-index + 1;
  }

  @debug $structured-stops;
  @return hsl-from-color(map.get(list.nth($structured-stops, 1), 'color'));
}

:root {
  --variable: '#{hsl-gradient-stops(0% red, 2 nearest 50% green, 100% blue)}';
}
