@use 'sass:list';
@use 'sass:map';
@use 'sass:math';
@use 'sass:meta';
@use 'sass:color';
@use 'sass:string';

@function hsl-from-color($color) {
  @return hsla(color.hue($color), color.saturation($color), color.lightness($color), color.alpha($color));
}

@function interpolate($start, $end, $fraction) {
  @if math.compatible($start, $end) {
    @return ($end - $start) * $fraction + $start;
  }

  @return calc((#{$end} - #{$start}) * #{$fraction} + #{$start});
}

// Support synonyms for directions.
@function normalize-direction($direction) {
  @if list.index(('clockwise', 'up', 'positive'), $direction) {
    @return 'clockwise';
  }

  @if list.index(('counter-clockwise', 'counterclockwise', 'anti-clockwise', 'anticlockwise', 'down', 'negative'), $direction) {
    @return 'counter-clockwise';
  }

  @if list.index(('nearest', 'closest', 'near', 'close'), $direction) {
    @return 'nearest';
  }

  @if list.index(('farthest', 'furthest', 'far'), $direction) {
    @return 'farthest';
  }
}

// Populate default values after all tokens in a stop have been structured.
@function normalize-structured-stop($stop, $stop-index, $stop-count) {
  // Normalize position.
  $position: map.get($stop, 'position');

  @if meta.type-of($position) == 'null' {
    @if $stop-index == 1 {
      $position: 0%;
    } @else if $stop-index == $stop-count {
      $position: 100%;
    } @else {
      $position: 'interpolate';
    }
  }

  // Error if color not provided.
  $color: map.get($stop, 'color');

  @if meta.type-of($color) == 'null' {
    @error 'All gradient stops must contain a color.';
  }

  $stop: map.set($stop, 'position', $position);

  // Normalize direction.
  $direction: map.get($stop, 'direction');

  @if meta.type-of($direction) == 'null' {
    $direction: 'nearest';
  }

  $stop: map.set($stop, 'direction', normalize-direction($direction));

  // Set default extra turns and error out if value is negative.
  $turns: map.get($stop, 'extra-turns');

  @if meta.type-of($turns) == 'null' {
    $stop: map.set($stop, 'extra-turns', 0);
  } @else if $turns < 0 {
    @error 'Negative values are invalid for extra turns.';
  }

  @return $stop;
}

@function resolve-interpolated-positions($stops) {
  $i: 1;

  // We do want to omit the last stop, so < instead of <=.
  @while $i < list.length($stops) {
    $interpolation-group-start: $i;
    $interpolation-group-end: $i;
    $stop: list.nth($stops, $i);
    @if map.get($stop, 'position') == 'interpolate' {

      $interpolation-group-active: true;

      @for $j from $i + 1 through list.length($stops) {
        @if $interpolation-group-active and map.get(list.nth($stops, $j), 'position') == 'interpolate' {
          $interpolation-group-end: $j;
        } @else {
          $interpolation-active: false;
        }
      }

      $start-position: map.get(list.nth($stops, $interpolation-group-start - 1), 'position');
      $end-position: map.get(list.nth($stops, $interpolation-group-end + 1), 'position');

      // Add 1 to make the subtraction inclusive. Add another 1 because x stops
      // divide the range into x + 1 parts.
      $total-increments: $interpolation-group-end - $interpolation-group-start + 1 + 1;

      $current-increment: 1;
      @for $j from $interpolation-group-start through $interpolation-group-end {
        $stops: list.set-nth($stops, $j, map.set(list.nth($stops, $j), 'position', interpolate($start-position, $end-position, math.div($current-increment, $total-increments))));
        $current-increment: $current-increment + 1;
      }
    }

    $i: $interpolation-group-end + 1;
  }

  @return $stops;
}

@function structure-stops($stops) {
  // What direction to go if two adjacent stops are exactly 180° apart in hue
  // and the current direction is 'closest'. (If the current direction is
  // 'farthest', 180°-apart colors will proceed in the opposite of the default
  // fallback direction.)
  $default-fallback-direction: 'clockwise';
  $structured-stops: ();
  $stop-count: list.length($stops);
  $stop-index: 1;
  // Loop over provided arguments.
  @each $stop in $stops {
    $structured-stop: ();
    // If a stop is just a string, it's either a CSS custom property, which can only be a position, or the new default fallback direction.
    @if meta.type-of($stop) == 'string' {
      $default-fallback-direction: $stop;
    } @else {
      @each $stop-token in $stop {
        // Color.
        @if meta.type-of($stop-token) == 'color' {
          $structured-stop: map.set($structured-stop, 'color', $stop-token);
        }
        // Position or extra turns.
        @else if meta.type-of($stop-token) == 'number' {
          // Extra turns.
          @if math.is-unitless($stop-token) {
            $structured-stop: map.set($structured-stop, 'extra-turns', $stop-token);

            @if $stop-index == 0 {
              @warn 'Extra turns on the first gradient stop are ignored; they apply to the transition from the previous stop, not into the next one.';
            }
          }
          // Position.
          @else {
            $structured-stop: map.set($structured-stop, 'position', $stop-token);
          }
        }
        // Direction into this stop, or a CSS Custom Property for position.
        @else if meta.type-of($stop-token) == 'string' {
          @if string.index($stop-token, 'var(') {
            $structured-stop: map.set($structured-stop, 'position', $stop-token);
          } @else {
            $structured-stop: map.set($structured-stop, 'direction', $stop-token);
          }

          @if $stop-index == 0 {
            @warn 'Direction on the first gradient stop is ignored; it applies to the transition from the previous stop, not into the next one.'
          }
        }
      }

      $structured-stops: list.append($structured-stops, normalize-structured-stop($structured-stop, $stop-index, $stop-count));
    }

    $stop-index: $stop-index + 1;
  }

  $structured-stops: resolve-interpolated-positions($structured-stops);
  @return ($structured-stops, $default-fallback-direction);
}

@function hsl-stops-from-rgb-stops($structure-result) {
  $stops: list.nth($structure-result, 1);
  $final-stops: ();
  $fallback-direction: list.nth($structure-result, 2);
  $opposite-fallback-direction: 'counter-clockwise';

  @if $fallback-direction == 'counter-clockwise' {
    $opposite-fallback-direction: 'clockwise'
  }

  $final-stops: list.append($final-stops, list.nth($stops, 1));

  @for $i from 1 through list.length($stops) - 1 {
    $stop1: list.nth($stops, $i);
    $stop2: list.nth($stops, $i + 1);
    $position1: map.get($stop1, 'position');
    $position2: map.get($stop2, 'position');
    $color1: map.get($stop1, 'color');
    $color2: map.get($stop2, 'color');
    $hue1: color.hue($color1);
    $hue2: color.hue($color2);
    $hue-difference: $hue2 - $hue1;

    $direction: map.get($stop2, 'direction');
    $extra-turns: map.get($stop2, 'extra-turns');
    $hue-change: false;

    // Change the direction to a fallback if necessary.
    @if math.abs($hue-difference) == 180deg {
      $hue-change: 180deg;
      @if $direction == 'nearest' {
        $direction: $fallback-direction;
      } @else if $direction == 'farthest' {
        $direction: $opposite-fallback-direction;
      }
    }

    // Resolve 'nearest' or 'farthest' to an absolute direction.
    @if list.index(('nearest', 'farthest'), $direction) {
      // Set variables for which directions do and do not involve a wrap from 0 to 360 or vice versa.
      $wrap-direction: 'counter-clockwise';
      $no-wrap-direction: 'clockwise';

      @if $hue-difference < 0 {
        $wrap-direction: 'clockwise';
        $no-wrap-direction: 'counter-clockwise';
      }

      // Determine the shortest direction.
      @if math.abs($hue-difference) < 180deg {
        $direction: $no-wrap-direction;
        $hue-change: math.abs($hue-difference) + (360deg * $extra-turns);
      } @else {
        $direction: $wrap-direction;
        $hue-change: (360deg - math.abs($hue-difference)) + (360deg * $extra-turns);
      }
    }

    @if $direction == 'counter-clockwise' {
      $hue-change: $hue-change * -1;
    }

    $start-hue: $hue1;
    $end-hue: $hue1 + $hue-change;

    @for $hue from math.round($start-hue) through math.round($end-hue) {
      @if $hue % 60 == 0deg and math.abs($hue-change) > 0 {
        $percentage: math.div($hue - $start-hue, $end-hue - $start-hue);
        $interpolated-color: hsla(
          $hue,
          interpolate(color.saturation($color1), color.saturation($color2), $percentage),
          interpolate(color.lightness($color1),  color.lightness($color2),  $percentage),
          interpolate(color.alpha($color1),      color.alpha($color2),      $percentage)
        );
        $interpolated-position: interpolate($position1, $position2, $percentage);
        $final-stops: list.append($final-stops, ('color': $interpolated-color, 'position': $interpolated-position));
      }
    }

    $final-stops: list.append($final-stops, $stop2);
  }

  $final-stops: list.append($final-stops, list.index($stops, list.length($stops)));

  @return $final-stops;
}

@function render-stops($stops) {
  $stops-string: '';

  @each $stop in $stops {
    @if($stop) {
      $stops-string: $stops-string + #{map.get($stop, 'color') map.get($stop, 'position')} + ', '
    }
  }

  @return string.slice($stops-string, 1, -3);
}

@function hsl-gradient-stops($stops...) {
  $i: 0;
  $structure-result: structure-stops($stops);
  $hsl-stops: hsl-stops-from-rgb-stops($structure-result);
  $final-stops: render-stops($hsl-stops);
  @return $final-stops;;
}

:root {
  background: linear-gradient(to right, #{hsl-gradient-stops(red 10%, hsl(180deg, 100%, 50%) 90%)});
}
